#!/bin/bash
###############################################################################
##
##    Section: Abstract Interface:
##      Declate abstract interface for reporting commands like 'ps' & 'images'.
##
###############################################################################
##
###############################################################################
##
##  Purpose:
##    Identifies specific reporting command by outputting its dlw name.
##
##  Inputs:
##    None
##    
##  Outputs:
##    When Successful:
##      SYSOUT - Name of dlw command.
##    When Failure: 
##      SYSERR - Displays informative error message.
##
###############################################################################
function VirtDockerReportingCommandNameGet () {
  ScriptUnwind $LINENO "Please override: $FUNCNAME".
}
###############################################################################
##
##  Purpose:
##    Provide a bash regex that uniquely detects a the specific Docker report
##    heading generated by the Docker report command.
##
##  Inputs:
##    None
## 
##  Outputs:
##    SYSOUT - bash regex expression that evaluates to "true" for the Docker
##        report heading when applied to the Docker command's first line of
##        output.
##
###############################################################################
function VirtDockerReportingHeadingRegex () {
  ScriptUnwind $LINENO "Please override: $FUNCNAME".
}
###############################################################################
##
##    Section: Common Impementation of virtual functions.
##      Implementation of virtual functions common to reporting commands.
##
###############################################################################
##
###############################################################################
##
##  Purpose:
##    Define both the options and arguments accepted by reporting commands.
##
###############################################################################
function VirtDockerCmmdOptionsArgsDef () {
local -r commandName="`VirtDockerReportingCommandNameGet`"
ComponentNmListArgument "$commandName" 'all'
ComponentVersionArgument 'cur'
ColumnHeadingRemove
ColumnSelectExclude
echo '--dlwparent single false=EXIST=true  "OptionsArgsBooleanVerify \<--dlwparent\>" required ""'
return 0
}
###############################################################################
##
##  Purpose:
##    Describes purpose and arguments for reporting commands.
##
###############################################################################
function VirtCmmdHelpDisplay () {
local -r commandName="`VirtDockerReportingCommandNameGet`"
ComponentNmListArgument "$commandName" 'all'

cat <<COMMAND_HELP_Purpose

Report on targeted Components' container(s).  Wraps Docker '$commandName' command.

Usage: dlw $commandName [OPTIONS] TARGET 

COMMAND_HELP_Purpose
  HelpCommandTarget
  HelpOptionHeading
  HelpComponentVersion 'cur'
  echo '    --dlwparent=false     Include prerequisite parent Components.'
  HelpNoExecuteDocker 'false'
  HelpShowDocker 'false'
  HelpColumnSelectExclude 'ComponentName/COMPONENT/16'
  HelpColumnHeadingRemove 'false'
  HelpHelpDisplay 'false'
  DockerOptionsFormat "$commandName"
}
###############################################################################
##
##  Purpose:
##    Determine if an extended column list has been specified. If it has,
##    extract column heading, position, and maximum width from the spec 
##    and create a structure that can direct the report heading and detail
##    generator.
##
##  Assumption:
##    Since bash variable names are passed to this routine, these names
##    cannot overlap the variable names locally declared within the
##    scope of this routine or is decendents.
##
##  Input:
##    $1 - Column specifier syntax.  Note - the column name
##         'all' is a reserved attribute name.  It signifies that all attributes
##         in every Component Property Bag should be included in the report.
##         'none' is also a reserved attribute name.  It signifies that no
##         extended attribute names should appear in the report.
##    $2 - Variable name to an associative array whose key is an attribute's
##         name and whose value relates a structure consisting of the
##         column's position, column's name, and potentially a truncation width.
##    
##  Output:
##    When Successful:
##      $2 - Contains values that direct generation of extended columns.
##
###############################################################################
function ColmIncludeDetermine () {
  local colmSpec="$1"
  local -r colmSetNm="$2"
  function WhitespaceLeadingTrailingTrim () {
    if [ "$#" -eq '1' ]; then return 1; fi
    if [ "$#" -gt '2' ]; then return 1; fi
    eval $2\=\"\$1\"
    return 0
  }
  local -i delimiterPos='0'
  local attrbName=''
  local colmHdrName=''
  local -i colmTruncWidth='0'
  local -i colmPosition='1'
  local -i delimInstCnt='0'
  local -i stateParse='0'
  while [ -n "$colmSpec" ]; do
    local endEntry='true'
    if DelimiterPosGet "$colmSpec" 'delimiterPos'; then endEntry='false'; fi
    (( ++delimInstCnt ))
    if [ $delimInstCnt -gt 3 ]; then
      ScriptError "Report column specifier contains too many delimiters for signal entry: '$colmSpec'. Should be '../../..[,../../..]'."
      return 1
    fi
    (( ++stateParse ))
    local value="${colmSpec:0:$delimiterPos-1}"
    if [ "$stateParse" -eq '1' ]; then
      if [ "${#value}" -lt '1' ]; then
        ScriptError "Attribute name was omitted or starts with delimiter: '$colmSpec'. Should be '../../..[,../../..]'."
        return 1
      fi
      if ! WhitespaceLeadingTrailingTrim $value 'value'; then
        ScriptError "Attribute name was omitted or contains spaces: '$colmSpec'."
        return 1
      fi
      attrbName="$value"
      local -i colmWidthMax="${#attrbName}"
    elif [ "$stateParse" -eq '2' ]; then
      colmHdrName="$value"
      local -i colmWidthMax="${#colmHdrName}"
    elif [ "$stateParse" -eq '3' ]; then
      if ! [[ "$value" =~ ^[0-9]*$ ]]; then
        ScriptError "Truncation width: '$value' must be numeric for column specifier of attribute: '$attrbName'."
        return 1
      fi
      colmTruncWidth="$value"
    fi
    if $endEntry; then
      local colmSetPacketTemp
      PacketCreateFromStrings 'ColName' "$colmHdrName" 'ColTruncWidth' "$colmTruncWidth" 'ColWidthMax' "$colmWidthMax" 'ColPosition' "$colmPosition" 'colmSetPacketTemp'
      eval $colmSetNm\[\"\$attrbName\"\]\=\"\$colmSetPacketTemp\"
      local colmHdrName=''
      local -i colmTruncWidth='0'
      local -i delimInstCnt='0'
      local -i stateParse='0'
      (( ++colmPosition ))
    fi
    colmSpec="${colmSpec:$delimiterPos}"
  done
  return 0
}
###############################################################################
##
##  Purpose:
##    Determine the location of the 'trailing' delimiter.  A trailing delimiter
##    defines the extent of the current token and allows for its complete
##    extraction.
##
##  Assumption:
##    Since bash variable names are passed to this routine, these names
##    cannot overlap the variable names locally declared within the
##    scope of this routine or is decendents.
##
##  Input:
##    $1 - Column specifier syntax to process.  Syntax supported:
##          <fieldName>[/<columnName][/<reportColmMaxWidth>][,<fieldName>[/<columnName][/<reportColmMaxWidth>]]
##    $2 - Variable name to return position (starting at 1), of the
##         next delimiter closest to the left side of the syntax
##         provided by $1.
##    
##  Output:
##    When Successful:
##      $2 - Contains the position of the next delimiter whose value
##           can be used to extract the next token.
##      Return code - Indicates more syntax to process.
##    Otherwise:
##      $2 - Contain the position of the next delimiter when greater than 0.
##      Return code - Indicates the 'end' of a specific column specifier and
##           when $2 == 0 signals no more syntax to process.
##
###############################################################################
function DelimiterPosGet () {
  local -r colmSpec="$1"
  local -r delimiterPosNm="$2"
  local -ir slashPos="`expr index "$colmSpec" '/'`"
  local -ir commaPos="`expr index "$colmSpec" ','`"
  if [ "$slashPos" -gt "$commaPos" ]; then
    if [ "$commaPos" -eq '0' ]; then
      eval $delimiterPosNm=\"\$slashPos\"
      return 0
    else
      # comma before next slash :: ending comma
      eval $delimiterPosNm=\"\$commaPos\"
    fi
  elif [ "$slashPos" -gt '0' ]; then
    # slash before ending comma :: next field in entry
    eval $delimiterPosNm=\"\$slashPos\"
    return 0
  elif [ "$commaPos" -gt '0' ]; then
    # no more slashes but a comma exists
    eval $delimiterPosNm=\"\$commaPos\"
  elif [ "${#colmSpec}" -gt '0' ]; then 
    # could not find a slash or comma treat end of line
    # as a delimiter. 
    eval $delimiterPosNm=\"\${\#colmSpec}\+\1\"
  else
    # nothing left to parse
    eval $delimiterPosNm=\'0\'
  fi
  return 1
}
###############################################################################
##
##  Purpose:
##    To create a Component's column bag.  A column bag contains extended 
##    attributes defined within an ImageGUID List.  Also, when a attribute
##    name of 'all' is specified in the include map, all known component
##    attribute names, available through the Component's packet, are included
##    in the report.
## 
##    Note:
##      > Some Components may support different attribute sets, in this
##        situation, this routine computes the union of all attribute
##        names across Components and the maximum lengths of their values.
##      > 'all' should never be used as a attribute name for a Component field.
##      > 'none' should never be used as a attribute name for a Component field.
##
##  Assumption:
##    Since bash variable names are passed to this routine, these names
##    cannot overlap the variable names locally declared within the
##    scope of this routine or is decendents.
##
##  Input:
##    $1 - Variable name to an associative array whose key contains extended
##         attribute names that should be included in the report and a property
##         bag that directs colum heading generation.  
##    $2 - Variable name to an associative array whose key is an extended
##         attribute name and value stored with a Component's GUID in its
##         Image GUID List or added to this list by the pipeline before
##         this step.
##    $3 - Variable name to an array that captures the attribute values
##         to be included in the report.  The values appear in the order
##         specified by the map represented by $1.  In the case of 'all',
##         the heading order reflects the sequence in which the attribute
##         was discovered.
##    
##  Output:
##    When Successful:
##      $1 - any newly detected extended attributes are added.  The maximum length
##           of each extended attribute value is potentially updated to reflect a 
##           new maximum.
##      $3 - Contains an array of attribute values that will appear
##           in the report ordered by the position specified in $1.
##
###############################################################################
function ColumnAttributesDiscern () {
  local -r colmIncludeMapNm="$1"
  local -r componentPacketMapNm="$2"
  local -r colmValueArrayNm="$3"

  eval local -i colmPosNext=\"\$\{\#$colmIncludeMapNm\[\@\]\}\"
  if [ "$colmPosNext" -lt '1' ]; then
    # no extended attribute processing requested.
    return 0;
  fi 
  eval local allDefault=\"\$\{$colmIncludeMapNm\[\'all\']\}\"
  local -A allColmMap
  if [ -n "$allDefault" ]; then
    # extract its property bag.
    AssociativeMapFromBuffer "$allDefault" 'allColmMap'
    #  since all entry must not be counted in current
    #  last column position, colmPosNext is already
    #  correct value.
  else
    # adjust to reflext the next available column position
    (( ++colmPosNext ))
  fi
  eval local -r componentPacket_np=\"\$\{\!$componentPacketMapNm\[\@\]\}\"
  local mapKey
  for mapKey in $componentPacket_np
  do
    eval local colmHdrBag=\"\$\{$colmIncludeMapNm\[\"\$mapKey\"\]\}\"
    if [ -n "$colmHdrBag" ]; then
      # specific column hdr entry already exists for attribute name
      local -A colmHdrBagMap
      PacketConvertToAssociativeMap "$colmHdrBag" 'colmHdrBagMap'
      local -i colmWidthMax="${colmHdrBagMap['ColWidthMax']}"
      local -i colmHdrPos="${colmHdrBagMap['ColPosition']}"
      local -i colmTruncWidth="${colmHdrBagMap['ColTruncWidth']}"
      local colmHdrName="${colmHdrBagMap['ColName']}"
    elif [ "${#allColmMap[@]}" -gt 0 ]; then 
      # all attributes selected. Include any attribute not explicitly
      # requested using appropriate 'all' settings.
      local -i colmHdrPos="$colmPosNext"
      (( ++colmPosNext ))
      local -i colmTruncWidth="${allColmMap['ColTruncWidth']}"
      local -i colmWidthMax="${#mapKey}"
      local colmHdrName="${allColmMap['ColName']}"
    else 
      # attribute not selected :: try next one.
      continue
    fi
    # attribute included, get its value
    eval local componentAttribValue=\"\$\{$componentPacketMapNm\[\"\$mapKey\"\]\}\"
    if [ "$colmWidthMax" -lt "${#componentAttribValue}" ]; then 
      colmWidthMax="${#componentAttribValue}"
    fi
    if [ "$colmWidthMax" -lt "$colmTruncWidth" ]; then
      colmWidthMax="$colmTruncWidth"
    fi
    PacketCreateFromStrings 'ColName' "$colmHdrName" 'ColTruncWidth' "$colmTruncWidth" 'ColPosition' "$colmHdrPos" 'ColWidthMax' "$colmWidthMax" 'colmHdrBag'
    # save potentially updated attributes column Heading Bag or create one.
    eval $colmIncludeMapNm\[\"\$mapKey\"\]\=\"\$colmHdrBag\"
    # record attribute value according to its position (0-based) in array property bag.
    eval $colmValueArrayNm\[\$colmHdrPos\-1\]\=\"\$componentAttribValue\"
  done
  return 0
}
###############################################################################
##
##  Purpose:
##    Determines if the provided text buffer contains tokens unique to 
##    Docker heading.
##
##  Input:
##    $1 - String that might be Docker heading.
##    VirtDockerReportingHeadingRegex - Callback function that outputs
##         a bash regex expression that detects a report's header.
##    
##  Output:
##    When Successful:
##      Detected heading.
##    Otherwise:
##      Not heading.
##
###############################################################################
function DockerHeadingSpecified () {
  if [[ "$1" =~ `VirtDockerReportingHeadingRegex` ]]; then return 0; fi
  return 1
}
###############################################################################
##
##  Purpose:
##    To generate the report Column headings for the desired extended 
##    attributes.
## 
##    Note:
##      > The column properties associated to 'all' will be ignored.
##
##  Assumption:
##    Since bash variable names are passed to this routine, these names
##    cannot overlap the variable names locally declared within the
##    scope of this routine or is decendents.
##
##  Input:
##    $1 - Variable name to an associative array whose key contains extended
##         attribute names that should be included in the report and a property
##         bag that directs colum heading generation.  
##    
##  Output:
##    When Successful:
##      SYSOUT - reflects appropriately padded column heading names.
##    When Failure:
##      SYSERR - message & script unwinds.
##
###############################################################################
function ExtendedHeadingsGenerate () {
  local -r colmIncludeMapNm="$1"
  eval local -ir numToInclude=\"\$\{\#$colmIncludeMapNm\[\@\]\}\"
  if [ "$numToInclude" -lt '1' ]; then
    # no extended attribute processing requested.
    echo ''
    return 0;
  fi 
  local -a colmHdrArray
  eval local -r colmIncludeMapNm_np=\"\$\{\!$colmIncludeMapNm\[\@\]\}\"
  local mapKey
  for mapKey in $colmIncludeMapNm_np
  do
    if [ "$mapKey" == 'all' ]; then continue; fi # ignore 'all' pseduo attribute name
    local colmHdrBag=\"\$\{$colmIncludeMapNm\[\"\$mapKey\"\]\}\"
    eval local \-\A colmHdrBag=\"\$\{$colmIncludeMapNm\[\"\$mapKey\"\]\}\"
    if [ -z "$colmHdrBag" ]; then ScriptUnwind $LINENO "Missing column header properties for attribute: '$mapKey'."; fi
    # unpack serialized column header poperties for current attribute.
    local -A colmHdrBagMap
    PacketConvertToAssociativeMap "$colmHdrBag" 'colmHdrBagMap'
    local -i colmWidthMax="${colmHdrBagMap['ColWidthMax']}"
    local -i colmHdrPos="${colmHdrBagMap['ColPosition']}"
    local -i colmTruncWidth="${colmHdrBagMap['ColTruncWidth']}"
    local colmHdrName="${colmHdrBagMap['ColName']}"
    if [ -z "$colmHdrName" ]; then
      # column header name not specified, use attribute name.
      colmHdrName="$mapKey"
    fi
    if [ "$colmTruncWidth" -gt '0' ] && [ "$colmWidthMax" -gt "$colmTruncWidth" ]; then
      # max column width shortened to truncation width.
      colmWidthMax="$colmTruncWidth"
    fi
    ReportColumnTruncPadding "$colmHdrName" "$colmWidthMax" 'colmHdrName'
    colmHdrArray[$colmHdrPos-1]="$colmHdrName"
  done
  # use array list operator to generate header line with single space character separating
  # every element, except last one.
  echo "${colmHdrArray[@]}"
  return 0
}
###############################################################################
##
##  Purpose:
##    To generate a partial report row aggregating the individual
##    extended Component attribute values, into a properly truncated/padded,
##    form to conform to the Report's Column headings.
## 
##  Assumption:
##    Since bash variable names are passed to this routine, these names
##    cannot overlap the variable names locally declared within the
##    scope of this routine or is decendents.
##
##  Input:
##    $1  - Variable name to an associative array whose key contains extended
##          attribute names that should be included in the report and a property
##          bag that directs colum heading generation.   
##    $2  - A typeset serialized bash array containing the extended attributes
##          to be displayed in the report.  typeset declares array with name
##          of 'colmBagArray'.
##    $3  - Variable name to contain the listed contents of this array once
##          it's been materialized and its values properly truncated/padded. 
##    
##  Output:
##    When Successful:
##      $2  - Contains aggregate string of properly padded/truncated
##            extended Component attribute values.
##
###############################################################################
function ExtendedColumnsGenerate () {
  local -A colmIncludeMapNm="$1"
  local -r serializedArray="$2"
  local partialRowOutNm="$3"

  eval local -ir numToInclude=\"\$\{\#$colmIncludeMapNm\[\@\]\}\"
  if [ "$numToInclude" -lt '1' ]; then
    # no extended attribute processing requested.
    eval $partialRowOutNm=\'\'
    return 0
  fi 

  if ! [[ "$serializedArray" =~ ^declare\ \-a\ colmBagArray=.* ]]; then
    ScriptUnwind $LINENO "Serialized array contents: '$serializedArray', does not begin with: 'declare -a colmBagArray='"
  fi
  eval $serializedArray
  eval local -r colmIncludeMapNm_np=\"\$\{\!$colmIncludeMapNm\[\@\]\}\"
  local mapKey
  for mapKey in $colmIncludeMapNm_np
  do
    if [ "$mapKey" == 'all' ]; then continue; fi # ignore 'all' pseduo attribute name
    eval local colmHdrBag=\"\$\{$colmIncludeMapNm\[\"\$mapKey\"\]\}\"
    if [ -z "$colmHdrBag" ]; then ScriptUnwind $LINENO "Missing column header properties for attribute: '$mapKey'."; fi
    # unpack serialized column header poperties for curren attribute.
    local -A colmHdrBagMap
    PacketConvertToAssociativeMap "$colmHdrBag" 'colmHdrBagMap'
    local -i colmWidthMax="${colmHdrBagMap['ColWidthMax']}"
    local -i colmHdrPos="${colmHdrBagMap['ColPosition']}"
    local -i colmTruncWidth="${colmHdrBagMap['ColTruncWidth']}"
    if [ "$colmTruncWidth" -gt '0' ] && [ "$colmWidthMax" -gt "$colmTruncWidth" ]; then
      # max column width shortened to truncation width.
      colmWidthMax="$colmTruncWidth"
    fi
    local columValueOut
    ReportColumnTruncPadding "${colmBagArray[$colmHdrPos-1]}" "$colmWidthMax" 'columValueOut'
    colmBagArray[$colmHdrPos-1]="$columValueOut"
  done
  # use array list operator to generate the aggregated partial row with a single space
  # character separating every column value, except last one.
  eval $partialRowOutNm=\"\$\{colmBagArray\[\@\]\}\"
  return 0
}
###############################################################################
##
##  Purpose:
##    Given some text, truncate or append spaces to string so it conforms
##    to desired length.
##
##  Assumption:
##    Since bash variable names are passed to this routine, these names
##    cannot overlap the variable names locally declared within the
##    scope of this routine or is decendents.
##
##  Input:
##    $1  - String to be truncated/spaced padded.
##    $2  - Maximum length of string.
##    $3  - Variable name that will accept transformed output.
##    
##  Output:
##    When Successful:
##      $3  - Contains truncated/padded string value.
##
###############################################################################
function ReportColumnTruncPadding () {
  local -r columnValue="$1"
  local -ir columnWidthMax=$2
  local -r columnOutNm="$3"
  local -ir valueLen="${#columnValue}"
  local -ir repeatCnt="$columnWidthMax-$valueLen"
  if [ "$repeatCnt" -lt '0' ]; then
    # field must be truncated
    eval $columnOutNm=\"\$\{columnValue\:0\:\$columnWidthMax\}\"
  else
    # field either exact size or must be padded
    eval $columnOutNm=\"\$columnValue\"
    local -i spaceAppend
    for (( spaceAppend=repeatCnt ; spaceAppend > 0 ; --spaceAppend )); do
      eval $columnOutNm=\"\$\{$columnOutNm\}\ \"
    done
  fi
  return 0
}
###############################################################################
##
##  Purpose:
##    Initiates the dlw pipline to identify targets, assemple and execute
##    reporing commands, and filter/augument their output.
##
##  Assumption:
##    Since bash variable names are passed to this routine, these names
##    cannot overlap the variable names locally declared within the
##    scope of this routine or is decendents.
##
##  Inputs:
##    $1 - Variable name to an array whose values contain the label names
##         of the options and agruments appearing on the command line in the
##         order specified by it.
##    $2 - Variable name to an associative array whose key is either the
##         option or argument label and whose value represents the value
##         associated to that label.
##    VirtDockerReportingCommandNameGet - Virtual callback function whose output
##         represents dlw command name.
##    
##  Outputs:
##    When Successful:
##      SYSOUT - Indicates build operation completed successfully.
##    When Failure: 
##      SYSERR - Displays informative error message.
##
###############################################################################
function VirtCmmdExecute (){
  local -r commandName="`VirtDockerReportingCommandNameGet`"
  VirtDockerMain "$1" "$2" "$commandName"
}
FunctionOverrideIncludeGet
###############################################################################
# 
# The MIT License (MIT)
# Copyright (c) 2014-2015 Richard Moyse License@Moyse.US
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
###############################################################################
#
# Docker and the Docker logo are trademarks or registered trademarks of Docker, Inc.
# in the United States and/or other countries. Docker, Inc. and other parties
# may also have trademark rights in other terms used herein.
#
###############################################################################
